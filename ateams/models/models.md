
A _model_ programmatically specifies a probability distribution over a combinatorial object like a graph, cubical complex, or polytope. Given one of these objects (e.g. `ateams.complexes.Cubical`), each model implements a _proposal function_ for sampling from the distribution it specifies. For example, `SwendsenWang` represents the Edwards-Sokal coupling of the [_plaquette random cluster model_ and _Potts lattice gauge theory_](https://link.springer.com/article/10.1007/s00220-025-05322-5) on subcomplexes of the $d$-fold, scale-$N$ cubical torus $\mathbb T^d_N$; its proposal function is a generalized version of the [_Swendsen-Wang algorithm_](https://link.aps.org/doi/10.1103/PhysRevLett.58.86).

The `SwendsenWang`, `InvadedCluster`, and `Nienhuis` models require performant sparse linear algebra over finite fields, for which we turn to [LinBox](https://github.com/linbox-team/linbox). The `InvadedCluster` and `Bernoulli` models require fast computation of persistent homology, for which we use [PHAT](https://www.sciencedirect.com/science/article/pii/S0747717116300098) (when sampling over $\mathbb Z/2\mathbb Z$) and a home-brew variant of [the "twist" algorithm proposed by Chen and Kerber](https://www.geometrie.tugraz.at/kerber/kerber_papers/ck-phcwat-11.pdf). Only the `Glauber` dynamics model is implemented in "pure Python," though it relies exclusively on NumPy.

The documentation for each model comes with performance information, viewable by clicking (e.g.) the "Performance over $\mathbb T^2_N$" button. Each configuration completed 100 iterations on Pangolin, a Dell Precision 5280 workstation with an 18-core Intel Xeosn W-2295 CPU clocked at 1.3GHz.

