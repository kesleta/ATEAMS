<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.3">
<title>ateams.statistics API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script>
$(document).ready(function() {
const buttons = document.querySelectorAll(".collapsible");
buttons.forEach(button => {
var tableId = "#" + button.id + "-table";
button.addEventListener("click", event => {
$(tableId).toggle();
});
});
})
</script>
<!-- Sidebar edits -->
<style>
a:hover {
text-decoration: underline;
}
a, a:visited {
color: #058;
transition: none;
}
header > h1 { display: none; }
.toc { display: none; }
img.resize {
min-width: 10vw;
max-width: 15vw;
display: block;
margin: 0 auto;
}
div.proof {
border: 1px solid black;
padding: 0em 1em;
width: 90%;
margin: 1em auto;
}
.tombstone {
margin-top: -2em;
float: right;
}
#index .two-column {
column-count: 1 !important;
}
#ateams {
margin-top: 0;
}
#sidebar {
width: 20vw;
font-size: 1rem;
scrollbar-width: none;
}
</style>
<!-- table edits -->
<style>
.collapsible {
border: 1px solid black;
background: none;
cursor: pointer;
padding: 2.5px 5px;
font-weight: bold;
}
.dataframe.profile-data-table {
margin: auto;
width: 75%;
display: none;
}
.dataframe.profile-data-table thead tr {
text-align: center !important;
}
.dataframe.profile-data-table thead {
border-bottom: 3px solid black;
}
.dataframe.profile-data-table tbody > tr:nth-of-type(9n) {
border-bottom: 3px solid black;
}
.dataframe.profile-data-table tbody tr th {
vertical-align: middle;
}
.dataframe.profile-data-table tbody tr td {
vertical-align: middle;
}
.dataframe.profile-data-table tbody > tr:nth-child(3n) {
:nth-child(n) {
border-bottom: 1px solid black;
}
}
.dataframe.profile-data-table tbody td {
text-align: center;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ateams.statistics</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ateams.statistics.always"><code class="name flex">
<span>def <span class="ident">always</span></span>(<span>model=None, distribution=None, burnIn=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An acceptance function which always accepts the proposed state; we do nothing
with the arguments to this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>Model</code></dt>
<dd>Optional argument; does nothing.</dd>
<dt><strong><code>distribution</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Optional argument; does nothing.</dd>
<dt><strong><code>burnIn</code></strong> :&ensp;<code>int</code></dt>
<dd>Optional argument; does nothing.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A function which always returns True.</p></div>
</dd>
<dt id="ateams.statistics.autocorrelation"><code class="name flex">
<span>def <span class="ident">autocorrelation</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the autocorrelation of a given observable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Iterable</code></dt>
<dd>An iterable, indexed by sample times, containing data
from a given observable.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An <code>np.ndarray</code> of autocorrelation data.</p></div>
</dd>
<dt id="ateams.statistics.constant"><code class="name flex">
<span>def <span class="ident">constant</span></span>(<span>temperature)</span>
</code></dt>
<dd>
<div class="desc"><p>A constant annealing schedule.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>temperature</code></strong> :&ensp;<code>float</code></dt>
<dd>The temperature to be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A function passed to a model constructor.</p></div>
</dd>
<dt id="ateams.statistics.critical"><code class="name flex">
<span>def <span class="ident">critical</span></span>(<span>field)</span>
</code></dt>
<dd>
<div class="desc"><p>A constant annealing schedule which calculates the critical temperature
of the model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>field</code></strong> :&ensp;<code>int</code></dt>
<dd>The order of the field we're over.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A function passed to a Model constructor that returns the critical
temperature of the Potts model.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ateams.statistics.Chain"><code class="flex name class">
<span>class <span class="ident">Chain</span></span>
<span>(</span><span>model,<br>accept=&lt;function always.&lt;locals&gt;._&gt;,<br>statistics={},<br>steps=10000)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulates a Markov chain on the given Model. For example, to generate 1000 samples
from 2-dimensional Potts lattice gauge theory with coefficients in <span><span class="MathJax_Preview">\mathbb Z/5\mathbb Z</span><script type="math/tex">\mathbb Z/5\mathbb Z</script></span>
and store the spins on each 1-cell and the occupied 2-cells, use something like</p>
<pre><code class="language-python">from ateams import Chain, Recorder
from ateams.statistics import critical
from ateams.complexes import Cubical
from ateams.models import SwendsenWang

# Construct the cubical complex; instantiate model, chain, and recorder.
C = Cubical().fromCorners([10]*4)
SW = SwendsenWang(C, dimension=2, field=7, temperature=critical(7))
M = Chain(SW, steps=1000)

rec = Recorder()

# Run the chain, storing the output.
with rec.record(&quot;out.lz&quot;) as rec:
        for (spins, satisfied) in M.progress():
                # You can store as many outputs as you'd like --- even ones
                # that aren't spit out by the model --- but they must be passed
                # to the `.store()` method as a tuple.
                rec.store((spins, satisfied))
</code></pre>
<p>The <code><a title="ateams.statistics.Recorder" href="#ateams.statistics.Recorder">Recorder</a></code> class stores the differences between consecutive iterations using
the <a href="github.com/lz4/lz4">LZ4 compression schema</a>, compressing the diffs in
chunks of (default) size 100. You can replay the data with the <code><a title="ateams.statistics.Player" href="#ateams.statistics.Player">Player</a></code>
class:</p>
<pre><code class="language-python">from ateams import Player

play = Player()

with play.playback(&quot;out.lz&quot;, steps=1000) as play:
        for (spins, satisfied) in play.progress():
                &lt;do whatever&gt;
</code></pre>
<p>Running the sampler and recording the data takes ~26 seconds (~38 it/s) on
an M2 MacBook Air; replaying the data takes ~0 seconds (~14,101 it/s). The
size of <code>out.lz</code> is ~1.8MB, so storing each cell's data requires <span><span class="MathJax_Preview">1/11</span><script type="math/tex">1/11</script></span>th
of a byte per iteration (amortized).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>Model</code></dt>
<dd>A Model (e.g. <code><a title="ateams.models.SwendsenWang" href="../models/index.html#ateams.models.SwendsenWang">SwendsenWang</a></code>)
generating the Markov chain.</dd>
<dt><strong><code>accept</code></strong> :&ensp;<code>Callable</code></dt>
<dd>A function that consumes the complex, model, and
state to determine whether we're going to a good place.</dd>
<dt><strong><code>statistics</code></strong> :&ensp;<code>dict</code></dt>
<dd>A mapping of names to functions which take the complex,
model, and state as argument. The Chain keeps track of these at
each iteration and stores whatever output is given.</dd>
<dt><strong><code>steps</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of iterations in the chain.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chain:
        &#34;&#34;&#34;
        Simulates a Markov chain on the given Model. For example, to generate 1000 samples
        from 2-dimensional Potts lattice gauge theory with coefficients in \(\mathbb Z/5\mathbb Z\)
        and store the spins on each 1-cell and the occupied 2-cells, use something like

        ```python
        from ateams import Chain, Recorder
        from ateams.statistics import critical
        from ateams.complexes import Cubical
        from ateams.models import SwendsenWang

        # Construct the cubical complex; instantiate model, chain, and recorder.
        C = Cubical().fromCorners([10]*4)
        SW = SwendsenWang(C, dimension=2, field=7, temperature=critical(7))
        M = Chain(SW, steps=1000)

        rec = Recorder()

        # Run the chain, storing the output.
        with rec.record(&#34;out.lz&#34;) as rec:
                for (spins, satisfied) in M.progress():
                        # You can store as many outputs as you&#39;d like --- even ones
                        # that aren&#39;t spit out by the model --- but they must be passed
                        # to the `.store()` method as a tuple.
                        rec.store((spins, satisfied))
        ```

        The `Recorder` class stores the differences between consecutive iterations using
        the [LZ4 compression schema](github.com/lz4/lz4), compressing the diffs in
        chunks of (default) size 100. You can replay the data with the `Player`
        class:
        
        ```python
        from ateams import Player

        play = Player()

        with play.playback(&#34;out.lz&#34;, steps=1000) as play:
                for (spins, satisfied) in play.progress():
                        &lt;do whatever&gt;
        ```

        Running the sampler and recording the data takes ~26 seconds (~38 it/s) on
        an M2 MacBook Air; replaying the data takes ~0 seconds (~14,101 it/s). The
        size of `out.lz` is ~1.8MB, so storing each cell&#39;s data requires \(1/11\)th
        of a byte per iteration (amortized).
        &#34;&#34;&#34;
        def __init__(self, model, accept=always(), statistics={}, steps=10000):
                &#34;&#34;&#34;
                Args:
                        model (Model): A Model (e.g. `ateams.models.SwendsenWang`)
                                generating the Markov chain.
                        accept (Callable): A function that consumes the complex, model, and
                                state to determine whether we&#39;re going to a good place.
                        statistics (dict): A mapping of names to functions which take the complex,
                                model, and state as argument. The Chain keeps track of these at
                                each iteration and stores whatever output is given.
                        steps (int): The number of iterations in the chain.
                &#34;&#34;&#34;
                self.model = model
                self.steps = steps
                self.accept = accept
                self._exitcode = 0
                self._warnings = 0

                # Store stats and things.
                self.functions = statistics
                self.statistics = { name: [] for name in self.functions.keys() }


        def __iter__(self):
                &#34;&#34;&#34;
                Initializes the Chain object as a generator.
                &#34;&#34;&#34;
                self.step = 0
                self.state = tuple([self.model.spins] + []*(self.model._returns-1))
                return self
        

        def __next__(self):
                &#34;&#34;&#34;
                Performs the computations specified by the proposal and acceptance schemes.
                &#34;&#34;&#34;
                # While we haven&#39;t reached the max number of steps, propose a new plan,
                # check whether it&#39;s acceptable/valid, and continue.
                while self.step &lt; self.steps:
                        # Propose the next state and check whether we want to accept it as
                        # the next state or not; assign whichever state is chosen to the
                        # Model.
                        try: proposed = self.model._proposal(self.step)
                        except NumericalInstabilityWarning:
                                self._exitcode = 2
                                self._warnings += 1
                                proposed = self.state

                        self.state = proposed if self.accept(self.state, proposed, self.step) else self.state
                        self.model._assign(self.state[0])

                        # Compute statistics.
                        for name, function in self.functions.items():
                                self.statistics[name].append(function(self.model, self.state))
                        
                        # Iterate.
                        self.step += 1
                        
                        return self.state
                
                raise StopIteration
        
        
        def progress(self, dynamic_ncols=True, desc=&#34;&#34;):
                &#34;&#34;&#34;
                Progress bar.

                Returns:
                        `tqdm` iterable.
                &#34;&#34;&#34;
                from tqdm.auto import tqdm
                return tqdm(self, total=self.steps, dynamic_ncols=dynamic_ncols, desc=desc)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ateams.statistics.Chain.progress"><code class="name flex">
<span>def <span class="ident">progress</span></span>(<span>self, dynamic_ncols=True, desc='')</span>
</code></dt>
<dd>
<div class="desc"><p>Progress bar.</p>
<h2 id="returns">Returns</h2>
<p><code>tqdm</code> iterable.</p></div>
</dd>
</dl>
</dd>
<dt id="ateams.statistics.Player"><code class="flex name class">
<span>class <span class="ident">Player</span></span>
</code></dt>
<dd>
<div class="desc"><p>Safely "replays" recorded <code><a title="ateams.statistics.Chain" href="#ateams.statistics.Chain">Chain</a></code> output.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Player():
        &#34;&#34;&#34;
        Safely &#34;replays&#34; recorded `Chain` output.
        &#34;&#34;&#34;
        def __init__(self): pass

        def playback(self, fp:str, steps=1000):
                &#34;&#34;&#34;
                Initialize playback; context management.

                Args:
                        fp (str): File in which records are stored.
                        steps (int=1000): How many steps in the chain? Only relevant for
                                displaying the progress bar.

                Returns:
                        This Player object.
                &#34;&#34;&#34;
                # Configure filepath, reader.
                self._fp = fp
                self._reader = lz4.frame.LZ4FrameFile(f&#34;{self._fp}&#34;, mode=&#34;rb&#34;)

                # Similar setup to the Recorder.
                self._current = None
                self._currentized = False

                self._loaded = []
                self._remaining = 0
                self._blocksize = 0
                self._configurationsize = -1

                # Compression markers.
                self._intrablockbreak = &#39;&lt;&lt;#&gt;&gt;&#39;
                self._interblockbreak = &#39;&lt;&lt;&lt;##&gt;&gt;&gt;&#39;
                self._interlistbreak = &#39;&lt;&gt;&#39;
                self._listsep = &#39; &#39;

                # Number of steps (progress bar only).
                self._steps = steps

                # Enter context management.
                return self.__enter__()
        

        def __iter__(self):
                &#34;&#34;&#34;
                This `Player` is a generator which yields states of the recorded chain.
                &#34;&#34;&#34;
                return self


        def __next__(self):
                &#34;&#34;&#34;
                Iteration magic method.
                &#34;&#34;&#34;
                # If there are no more configurations remaining in this block, load the
                # next block.
                if self._remaining == 0:
                        # Check whether we&#39;re EOF.
                        try:
                                unconfigured = self._reader.readline()
                                assert unconfigured != b&#39;&#39;
                        except:
                                raise StopIteration
                        
                        # Split on block markers...
                        unpackedlines = unconfigured.decode().strip().split(self._interblockbreak)

                        # ... then on intra-block markers (indicating iterations) ...
                        unpackediterations = [l.split(self._intrablockbreak) for l in unpackedlines]

                        # ... then on intra-list markers (indicating different arrays within each iteration)...
                        self._loaded = [[s.split(self._interlistbreak) for s in l] for l in unpackediterations]
                        self._loaded = [
                                [
                                        [np.fromstring(i, sep=self._listsep, dtype=int), np.fromstring(v, sep=self._listsep, dtype=int)]
                                        for i, v in iteration
                                ]
                                for iteration in self._loaded   
                        ]

                        # Compute the number of configurations that need to be reported and
                        # the size of the currently-loaded block (in iterations).
                        self._remaining = len(self._loaded)
                        self._blocksize = len(self._loaded)

                        # Check if we need to load an initial configuration; this only
                        # happens on the first step.
                        if not self._currentized:
                                self._current = tuple([self._loaded[0][i][1] for i in range(len(self._loaded[0]))])
                                self._configurationsize = len(self._current)
                                self._currentized = True

                # Load the next configuration, modify the current one.
                nextup = self._loaded[self._blocksize-self._remaining]

                for i in range(self._configurationsize):
                        indices, values = nextup[i]
                        self._current[i][indices] = values
                
                # Decrement the number of configurations remaining in the block, and
                # return the current(ly modified) configuration.
                self._remaining -= 1

                return self._current

        def __enter__(self):
                &#34;&#34;&#34;
                Required context management magic method.
                &#34;&#34;&#34;
                return self


        def __exit__(self, exc_type, exc_value, exc_tb):
                &#34;&#34;&#34;
                Required context management magic method; kills the reader and the file.
                &#34;&#34;&#34;
                self._reader.close()

        
        def progress(self):
                from tqdm.auto import tqdm
                return tqdm(self, total=self._steps)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ateams.statistics.Player.playback"><code class="name flex">
<span>def <span class="ident">playback</span></span>(<span>self, fp: str, steps=1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize playback; context management.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fp</code></strong> :&ensp;<code>str</code></dt>
<dd>File in which records are stored.</dd>
<dt><strong><code>steps</code></strong> :&ensp;<code>int=1000</code></dt>
<dd>How many steps in the chain? Only relevant for
displaying the progress bar.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This Player object.</p></div>
</dd>
<dt id="ateams.statistics.Player.progress"><code class="name flex">
<span>def <span class="ident">progress</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="ateams.statistics.Recorder"><code class="flex name class">
<span>class <span class="ident">Recorder</span></span>
</code></dt>
<dd>
<div class="desc"><p>Safely "records" states from a Chain by tracking changes between successive
states, and writing these changes &mdash; alongside the initial state &mdash; to
file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Recorder:
        &#34;&#34;&#34;
        Safely &#34;records&#34; states from a Chain by tracking changes between successive
        states, and writing these changes --- alongside the initial state --- to
        file.
        &#34;&#34;&#34;
        def __init__(self): pass

        def record(self, fp: str, blocksize=100):
                &#34;&#34;&#34;
                Called to configure the recording apparatus for the Chain, and *should*
                be used as a context manager (i.e. with the `with` statement).

                Args:
                        fp (str): Filename.
                        block (int=100): Number of states to bundle together before compressing. 

                Returns:
                        This `Recorder` object.

                
                &#34;&#34;&#34;
                # Configure filepath, writer.
                self._fp = fp
                self._writer = lz4.frame.LZ4FrameFile(f&#34;{self._fp}&#34;, mode=&#34;wb&#34;, compression_level=9)
                
                # Save the chain for access during iteration; set the &#34;previous&#34; state to
                # be all -1s, since the first state yielded by iterating over the Chain
                # is the initial state, and we need to record the whole thing; fix a list
                # of possible integer states for later.
                self.previous = None
                self._previous = False

                self._blocksize = blocksize
                self._block = []
                self._stored = 0

                # Compression markers.
                self._intrablockbreak = &#39;&lt;&lt;#&gt;&gt;&#39;
                self._interblockbreak = &#39;&lt;&lt;&lt;##&gt;&gt;&gt;&#39;
                self._interlistbreak = &#39;&lt;&gt;&#39;
                
                # Enter the context manager.
                return self.__enter__()


        def store(self, state) -&gt; None:
                &#34;&#34;&#34;
                Stores a state yielded by iteration over a `Chain`.

                Args:
                        state (tuple): Tuple of NumPy arrays to be written to file.
                &#34;&#34;&#34;
                # Check whether we&#39;ve received any arguments before; if not, initialize
                # a list to keep track of &#34;previous&#34; arguments. We expect the arguments
                # here to be numpy arrays.

                # Check whether we have any previously-stored data.
                if not self._previous:
                        self.previous = tuple(-np.ones(shape=s.shape, dtype=s.dtype) for s in state)
                        self._previous = True

                subblock = []
                
                # Get diffs; store.
                for i in range(len(state)):
                        # Compute the diff and store.
                        diff = np.flatnonzero(~np.equal(state[i], self.previous[i]))
                        self.previous[i][diff] = state[i][diff][::]

                        # Add the encoded dictionary of diffs to the subblock.
                        subblock.append(f&#34;{&#39; &#39;.join(diff.astype(str))}{self._interlistbreak}{&#39; &#39;.join(state[i][diff].astype(str))}&#34;)

                # Increment the number of iterations we&#39;ve stored; if we&#39;ve reached the
                # limit, compress, write to file, and begin again.
                self._block.append(subblock)
                self._stored += 1

                if self._stored == self._blocksize:
                        self._writer.write(
                                (self._interblockbreak.join(
                                        self._intrablockbreak.join(subblock)
                                        for subblock in self._block
                                ) + &#34;\n&#34;).encode()
                        )

                        # Flush the block/#stored.
                        self._block = []
                        self._stored = 0

        
        def __enter__(self):
                &#34;&#34;&#34;
                Required context management magic method.
                &#34;&#34;&#34;
                return self


        def __exit__(self, exc_type, exc_value, exc_tb):
                &#34;&#34;&#34;
                Required context management magic method: writes what&#39;s left of the cache
                to file, then closes the writer.
                &#34;&#34;&#34;
                # If we&#39;ve finished storing but there&#39;s still stuff left in the cache,
                # write that to file too.
                if len(self._block):
                        self._writer.write(
                                (self._interblockbreak.join(
                                        self._intrablockbreak.join(subblock)
                                        for subblock in self._block
                                ) + &#34;\n&#34;).encode()
                        )
                
                self._writer.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ateams.statistics.Recorder.record"><code class="name flex">
<span>def <span class="ident">record</span></span>(<span>self, fp: str, blocksize=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Called to configure the recording apparatus for the Chain, and <em>should</em>
be used as a context manager (i.e. with the <code>with</code> statement).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fp</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename.</dd>
<dt><strong><code>block</code></strong> :&ensp;<code>int=100</code></dt>
<dd>Number of states to bundle together before compressing. </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This <code><a title="ateams.statistics.Recorder" href="#ateams.statistics.Recorder">Recorder</a></code> object.</p></div>
</dd>
<dt id="ateams.statistics.Recorder.store"><code class="name flex">
<span>def <span class="ident">store</span></span>(<span>self, state) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Stores a state yielded by iteration over a <code><a title="ateams.statistics.Chain" href="#ateams.statistics.Chain">Chain</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Tuple of NumPy arrays to be written to file.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<!-- include a script for adding stuff to the end of proofs. -->
<script>
// Get all the proofs in the document.
proofs = document.getElementsByClassName("proof");
// For each of the proofs, attach a floating child element in the bottom-right
// corner.
for (var proof of proofs) {
// Create a proof-ending tombstone.
square = document.createElement("div");
square.className = "tombstone";
square.innerHTML = "◼️";
// Attach the tombstone to the proof.
proof.appendChild(square);
}
</script>
<header>
<a class="homelink" rel="home" title="ATEAMS" href="https://github.com/apizzimenti/ATEAMS">
<img class="resize" src="https://github.com/apizzimenti/ATEAMS/blob/feature/performant-sparse/docs/essential-cycle.jpeg?raw=true" alt="Homological percolation on the torus.">
</a>
</header>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ateams" href="../index.html">ateams</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ateams.statistics.always" href="#ateams.statistics.always">always</a></code></li>
<li><code><a title="ateams.statistics.autocorrelation" href="#ateams.statistics.autocorrelation">autocorrelation</a></code></li>
<li><code><a title="ateams.statistics.constant" href="#ateams.statistics.constant">constant</a></code></li>
<li><code><a title="ateams.statistics.critical" href="#ateams.statistics.critical">critical</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ateams.statistics.Chain" href="#ateams.statistics.Chain">Chain</a></code></h4>
<ul class="">
<li><code><a title="ateams.statistics.Chain.progress" href="#ateams.statistics.Chain.progress">progress</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ateams.statistics.Player" href="#ateams.statistics.Player">Player</a></code></h4>
<ul class="">
<li><code><a title="ateams.statistics.Player.playback" href="#ateams.statistics.Player.playback">playback</a></code></li>
<li><code><a title="ateams.statistics.Player.progress" href="#ateams.statistics.Player.progress">progress</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ateams.statistics.Recorder" href="#ateams.statistics.Recorder">Recorder</a></code></h4>
<ul class="">
<li><code><a title="ateams.statistics.Recorder.record" href="#ateams.statistics.Recorder.record">record</a></code></li>
<li><code><a title="ateams.statistics.Recorder.store" href="#ateams.statistics.Recorder.store">store</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.3</a>.</p>
</footer>
</body>
</html>
